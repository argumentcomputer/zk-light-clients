// Copyright (c) Yatima, Inc.
// SPDX-License-Identifier: Apache-2.0

//! # Proofs Module
//!
//! This module contains the logic for generating, executing, proving, and verifying proofs for the
//! light client. The light client is responsible for fetching the data necessary to prove sync
//! committee changes and value inclusion in the state of the Ethereum network, and to leverage this
//! data to generate proofs for them using Sphinx.
//!
//! We have one prover for each proof, sync committee change and inclusion. Those prover have two
//! modes: execution and proof generation (that can either generate STARK or SNARK proofs). The prover
//! also serves as a verifier for the proofs.
//!
//! ## Sub-modules
//!
//! - `committee_change`: The prover for the sync committee change proof.
//!
//! For more detailed information, users should refer to the specific documentation for each
//! sub-module.

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use sphinx_sdk::{SphinxPlonkBn254Proof, SphinxProof, SphinxProofWithPublicValues, SphinxStdin};

pub mod committee_change;
pub mod error;
pub mod inclusion;

/// The proving mode for the prover.
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub enum ProvingMode {
    STARK,
    SNARK,
}

impl ProvingMode {
    /// Returns a boolean indicating if the proving mode is STARK.
    ///
    /// # Returns
    ///
    /// A boolean indicating if the proving mode is STARK.
    pub const fn is_stark(&self) -> bool {
        matches!(self, ProvingMode::STARK)
    }

    /// Returns a serialized representation of the enum.
    ///
    /// # Returns
    ///
    /// A u8 representing the enum.
    pub const fn to_bytes(&self) -> u8 {
        match self {
            ProvingMode::STARK => 0,
            ProvingMode::SNARK => 1,
        }
    }

    /// Returns a ProvingMode from a serialized representation.
    ///
    /// # Arguments
    ///
    /// * `bytes` - The serialized representation of the enum.
    ///
    /// # Returns
    ///
    /// The ProvingMode.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        match bytes[0] {
            0 => Ok(ProvingMode::STARK),
            1 => Ok(ProvingMode::SNARK),
            _ => Err(anyhow!("Invalid proving mode")),
        }
    }
}

/// The proof type generated by the prover.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ProofType {
    STARK(SphinxProof),
    SNARK(SphinxPlonkBn254Proof),
}

impl ProofType {
    /// Returns a boolean indicating if the proof type is STARK.
    ///
    /// # Returns
    ///
    /// A boolean indicating if the proof type is STARK.
    pub const fn is_stark(&self) -> bool {
        matches!(self, ProofType::STARK(_))
    }

    /// Serialize the proof type to bytes.
    ///
    /// # Returns
    ///
    /// The serialized proof type.
    pub fn to_bytes(&self) -> Result<Vec<u8>> {
        let mut bytes = vec![];

        match self {
            ProofType::STARK(proof) => {
                bytes.extend_from_slice(&[0]);

                bytes.extend_from_slice(
                    &serde_json::to_vec(&(proof.clone() as SphinxProofWithPublicValues<_>))
                        .map_err(|err| anyhow!(err))?,
                );

                Ok(bytes)
            }
            ProofType::SNARK(proof) => {
                bytes.extend_from_slice(&[1]);
                bytes.extend_from_slice(
                    &serde_json::to_vec(&(proof.clone() as SphinxProofWithPublicValues<_>))
                        .map_err(|err| anyhow!(err))?,
                );

                Ok(bytes)
            }
        }
    }

    /// Deserialize the proof type from bytes.
    ///
    /// # Arguments
    ///
    /// * `bytes` - The serialized proof type.
    ///
    /// # Returns
    ///
    /// The proof type.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        match bytes[0] {
            0 => {
                let proof = serde_json::from_slice::<SphinxProof>(&bytes[1..])
                    .map_err(|err| anyhow!(err))?;

                Ok(ProofType::STARK(proof as SphinxProof))
            }
            1 => {
                let proof = serde_json::from_slice::<SphinxPlonkBn254Proof>(&bytes[1..])
                    .map_err(|err| anyhow!(err))?;

                Ok(ProofType::SNARK(proof))
            }
            _ => Err(anyhow!("Invalid proof type")),
        }
    }
}

impl From<ProvingMode> for String {
    fn from(mode: ProvingMode) -> String {
        match mode {
            ProvingMode::STARK => "STARK".to_string(),
            ProvingMode::SNARK => "SNARK".to_string(),
        }
    }
}

impl TryFrom<&str> for ProvingMode {
    type Error = anyhow::Error;

    fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
        match value {
            "STARK" => Ok(ProvingMode::STARK),
            "SNARK" => Ok(ProvingMode::SNARK),
            _ => Err(anyhow!("Invalid proving mode")),
        }
    }
}

/// `Prover` is a trait that embodies a prover in the context of our Light Client. It is dedicated to
/// a given program and has a specific input and output type.
pub trait Prover {
    /// The program to prove and verify.
    const PROGRAM: &'static [u8];

    /// The error type for the prover.
    type Error;

    /// The input type for the prover.
    type StdIn;

    /// The output type for the prover.
    type StdOut;

    /// Generate the Sphinx stdin for the prover.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    ///
    /// # Returns
    ///
    /// The Sphinx stdin.
    fn generate_sphinx_stdin(&self, inputs: Self::StdIn) -> Result<SphinxStdin, Self::Error>;

    /// Execute the program, useful to get the cycles that the program will take.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    ///
    /// # Returns
    ///
    /// The output of the prover.
    fn execute(&self, inputs: Self::StdIn) -> Result<Self::StdOut, Self::Error>;

    /// Generate a proof for the program. The proof can either be a STARK or a SNARK proof.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    /// * `mode` - The proof type to generate.
    ///
    /// # Returns
    ///
    /// The proof.
    fn prove(&self, inputs: Self::StdIn, mode: ProvingMode) -> Result<ProofType, Self::Error>;

    /// Verify a proof for the program.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof to verify.
    ///
    /// # Returns
    ///
    /// An empty result if the proof is valid.
    fn verify(&self, proof: &ProofType) -> Result<(), Self::Error>;
}
