// Copyright (c) Yatima, Inc.
// SPDX-License-Identifier: Apache-2.0

//! # Proofs Module
//!
//! This module contains the logic for generating, executing, proving, and verifying proofs for the
//! light client. The light client is responsible for fetching the data necessary to prove sync
//! committee changes and value inclusion in the state of the Ethereum network, and to leverage this
//! data to generate proofs for them using Sphinx.
//!
//! We have one prover for each proof, sync committee change and inclusion. Those prover have two
//! modes: execution and proof generation (that can either generate STARK or SNARK proofs). The prover
//! also serves as a verifier for the proofs.
//!
//! ## Sub-modules
//!
//! - `committee_change`: The prover for the sync committee change proof.
//!
//! For more detailed information, users should refer to the specific documentation for each
//! sub-module.

use anyhow::{anyhow, Result};
use sphinx_sdk::{SphinxPlonkBn254Proof, SphinxProof, SphinxStdin};

pub mod committee_change;
mod error;

/// The proving mode for the prover.
#[derive(Debug, Clone)]
pub enum ProvingMode {
    STARK,
    SNARK,
}

/// The proof type generated by the prover.
pub enum ProofType {
    STARK(SphinxProof),
    SNARK(SphinxPlonkBn254Proof),
}

impl From<ProvingMode> for String {
    fn from(mode: ProvingMode) -> String {
        match mode {
            ProvingMode::STARK => "STARK".to_string(),
            ProvingMode::SNARK => "SNARK".to_string(),
        }
    }
}

impl TryFrom<&str> for ProvingMode {
    type Error = anyhow::Error;

    fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
        match value {
            "STARK" => Ok(ProvingMode::STARK),
            "SNARK" => Ok(ProvingMode::SNARK),
            _ => Err(anyhow!("Invalid proving mode")),
        }
    }
}

/// `Prover` is a trait that embodies a prover in the context of our Light Client. It is dedicated to
/// a given program and has a specific input and output type.
pub trait Prover {
    /// The program to prove and verify.
    const PROGRAM: &'static [u8];

    /// The error type for the prover.
    type Error;

    /// The input type for the prover.
    type StdIn;

    /// The output type for the prover.
    type StdOut;

    /// Generate the Sphinx stdin for the prover.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    ///
    /// # Returns
    ///
    /// The Sphinx stdin.
    fn generate_sphinx_stdin(&self, inputs: Self::StdIn) -> Result<SphinxStdin, Self::Error>;

    /// Execute the program, useful to get the cycles that the program will take.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    ///
    /// # Returns
    ///
    /// The output of the prover.
    fn execute(&self, inputs: Self::StdIn) -> Result<Self::StdOut, Self::Error>;

    /// Generate a proof for the program. The proof can either be a STARK or a SNARK proof.
    ///
    /// # Arguments
    ///
    /// * `inputs` - The input for the prover.
    /// * `mode` - The proof type to generate.
    ///
    /// # Returns
    ///
    /// The proof.
    fn prove(&self, inputs: Self::StdIn, mode: ProvingMode) -> Result<ProofType, Self::Error>;

    /// Verify a proof for the program.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof to verify.
    ///
    /// # Returns
    ///
    /// An empty result if the proof is valid.
    fn verify(&self, proof: &ProofType) -> Result<(), Self::Error>;
}
